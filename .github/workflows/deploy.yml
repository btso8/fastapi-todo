name: Bootstrap + Deploy (ECS Fargate)

on:
  push:
    branches: ["main"]
  workflow_dispatch: {}

permissions:
  id-token: write
  contents: read

env:
  AWS_REGION: eu-west-2
  CONTAINER_NAME: fastapi-todo
  OIDC_ROLE_NAME: github-actions-oidc-ecs-deployer
  TF_VAR_github_owner: btso8
  TF_VAR_github_repo: fastapi-todo
  TF_VAR_oidc_role_name: github-actions-oidc-ecs-deployer

jobs:
  bootstrap-iam:
    runs-on: ubuntu-latest
    outputs:
      created: ${{ steps.check-role.outputs.created }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Check if deploy role exists
        id: check-role
        env:
          AWS_REGION: ${{ env.AWS_REGION }}
          OIDC_ROLE_NAME: ${{ env.OIDC_ROLE_NAME }}
          AWS_ACCESS_KEY_ID:     ${{ secrets.AWS_BOOTSTRAP_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_BOOTSTRAP_SECRET_ACCESS_KEY }}
        run: |
          set -euo pipefail
          if aws iam get-role --role-name "$OIDC_ROLE_NAME" >/dev/null 2>&1; then
            echo "created=false" >> "$GITHUB_OUTPUT"
            echo "Deploy role already exists."
          else
            echo "created=true" >> "$GITHUB_OUTPUT"
            echo "Deploy role not found; will bootstrap."
          fi

      - name: Setup Terraform
        if: steps.check-role.outputs.created == 'true'
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.9.6

      - name: Terraform init (bootstrap)
        if: steps.check-role.outputs.created == 'true'
        env:
          AWS_ACCESS_KEY_ID:     ${{ secrets.AWS_BOOTSTRAP_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_BOOTSTRAP_SECRET_ACCESS_KEY }}
        working-directory: ./terraform
        run: |
          set -euxo pipefail
          terraform init -input=false -no-color

      - name: Import existing GitHub OIDC provider (if present)
        if: steps.check-role.outputs.created == 'true'
        env:
          AWS_ACCESS_KEY_ID:     ${{ secrets.AWS_BOOTSTRAP_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_BOOTSTRAP_SECRET_ACCESS_KEY }}
          AWS_ACCOUNT_ID:        ${{ secrets.AWS_ACCOUNT_ID }}
        working-directory: ./terraform
        run: |
          set -euo pipefail
          terraform import \
            aws_iam_openid_connect_provider.github \
            arn:aws:iam::${AWS_ACCOUNT_ID}:oidc-provider/token.actions.githubusercontent.com || true

      - name: Bootstrap OIDC provider + deploy role (Terraform)
        if: steps.check-role.outputs.created == 'true'
        env:
          AWS_ACCESS_KEY_ID:     ${{ secrets.AWS_BOOTSTRAP_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_BOOTSTRAP_SECRET_ACCESS_KEY }}
        working-directory: ./terraform
        run: |
          set -euxo pipefail
          terraform apply -input=false -auto-approve \
            -target=aws_iam_openid_connect_provider.github \
            -target=aws_iam_role.github_actions_deployer \
            -target=aws_iam_role_policy_attachment.deployer_admin

  build-and-deploy:
    runs-on: ubuntu-latest
    needs: [bootstrap-iam]

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: ${{ env.AWS_REGION }}
          role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/${{ env.OIDC_ROLE_NAME }}

      - name: Who am I
        run: aws sts get-caller-identity

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.9.6

      - name: Terraform init/plan/apply (full infra)
        working-directory: ./terraform
        run: |
          set -euxo pipefail
          terraform init -input=false -no-color
          terraform plan -input=false -no-color -out tfplan
          terraform apply -input=false -auto-approve tfplan

      - name: Capture outputs
        id: tfout
        working-directory: ./terraform
        run: |
          set -euo pipefail
          terraform output -json > tf_outputs.json
          repo=$(jq -r '.ecr_repository_url.value' tf_outputs.json)
          cluster=$(jq -r '.cluster_name.value' tf_outputs.json)
          service=$(jq -r '.service_name.value' tf_outputs.json)
          echo "repo=$repo"       >> "$GITHUB_OUTPUT"
          echo "cluster=$cluster" >> "$GITHUB_OUTPUT"
          echo "service=$service" >> "$GITHUB_OUTPUT"

      - name: Login to ECR
        env:
          REPO: ${{ steps.tfout.outputs.repo }}
          AWS_REGION: ${{ env.AWS_REGION }}
        run: |
          set -euo pipefail
          REGISTRY="${REPO%%/*}"
          aws ecr get-login-password --region "$AWS_REGION" \
          | docker login --username AWS --password-stdin "$REGISTRY"

      - name: Build & push image
        id: buildpush
        env:
          REPO: ${{ steps.tfout.outputs.repo }}
        run: |
          set -euo pipefail
          GIT_SHA="${GITHUB_SHA::7}"
          docker build -t "$REPO:latest" -t "$REPO:$GIT_SHA" .
          docker push "$REPO:latest"
          docker push "$REPO:$GIT_SHA"
          echo "image_tag=$GIT_SHA" >> "$GITHUB_OUTPUT"

      - name: Update ECS service to new image
        env:
          CLUSTER:   ${{ steps.tfout.outputs.cluster }}
          SERVICE:   ${{ steps.tfout.outputs.service }}
          CONTAINER: ${{ env.CONTAINER_NAME }}
          NEW_IMAGE: ${{ steps.tfout.outputs.repo }}:${{ steps.buildpush.outputs.image_tag }}
        run: |
          set -euo pipefail
          TD_ARN=$(aws ecs describe-services --cluster "$CLUSTER" --services "$SERVICE" --query "services[0].taskDefinition" --output text)
          aws ecs describe-task-definition --task-definition "$TD_ARN" --query "taskDefinition" > td.json
          jq --arg name "$CONTAINER" --arg image "$NEW_IMAGE" '
            .containerDefinitions |= (map(if .name==$name then .image=$image else . end))
            | del(.taskDefinitionArn,.revision,.status,.requiresAttributes,.compatibilities,.registeredAt,.registeredBy)
          ' td.json > new-td.json
          NEW_TD_ARN=$(aws ecs register-task-definition --cli-input-json file://new-td.json --query "taskDefinition.taskDefinitionArn" --output text)
          aws ecs update-service --cluster "$CLUSTER" --service "$SERVICE" --task-definition "$NEW_TD_ARN"
          aws ecs wait services-stable --cluster "$CLUSTER" --services "$SERVICE"
