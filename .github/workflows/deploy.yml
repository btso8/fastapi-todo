name: Bootstrap + Deploy (ECS Fargate)

on:
  push:
    branches: [ "main" ]
  workflow_dispatch: {}

permissions:
  id-token: write
  contents: read

env:
  AWS_REGION: eu-west-2
  CONTAINER_NAME: fastapi-todo
  OIDC_ROLE_NAME: github-actions-oidc-ecs-deployer

jobs:
  bootstrap-iam:
    runs-on: ubuntu-latest
    outputs:
      created: ${{ steps.check-role.outputs.created }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Check if deploy role exists
        id: check-role
        env:
          AWS_REGION: ${{ env.AWS_REGION }}
          OIDC_ROLE_NAME: ${{ env.OIDC_ROLE_NAME }}
          AWS_ACCESS_KEY_ID:     ${{ secrets.AWS_BOOTSTRAP_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_BOOTSTRAP_SECRET_ACCESS_KEY }}
        run: |
          set -euo pipefail
          if aws iam get-role --role-name "$OIDC_ROLE_NAME" >/dev/null 2>&1; then
            echo "created=false" >> "$GITHUB_OUTPUT"
            echo "Deploy role already exists."
          else
            echo "created=true" >> "$GITHUB_OUTPUT"
            echo "Deploy role not found; will bootstrap."
          fi

      - name: Setup Terraform
        if: steps.check-role.outputs.created == 'true'
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.9.6

      - name: Bootstrap OIDC provider + deploy role (Terraform)
        if: steps.check-role.outputs.created == 'true'
        env:
          AWS_ACCESS_KEY_ID:     ${{ secrets.AWS_BOOTSTRAP_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_BOOTSTRAP_SECRET_ACCESS_KEY }}
        working-directory: ./terraform
        run: |
          set -euxo pipefail
          terraform init -input=false -no-color
          terraform apply -input=false -auto-approve \
            -target=aws_iam_openid_connect_provider.github \
            -target=aws_iam_role.github_actions_deployer \
            -target=aws_iam_role_policy_attachment.deployer_admin

  build-and-deploy:
    runs-on: ubuntu-latest
    needs: [bootstrap-iam]

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: ${{ env.AWS_REGION }}
          role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/${{ env.OIDC_ROLE_NAME }}

      - name: Who am I
        run: aws sts get-caller-identity

      - name: Set deploy vars
        id: setvars
        run: |
          echo "repo=${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/fastapi-todo" >> "$GITHUB_OUTPUT"
          echo "cluster=fastapi-todo-cluster" >> "$GITHUB_OUTPUT"
          echo "service=fastapi-todo-svc" >> "$GITHUB_OUTPUT"

      - name: Login to ECR
        env:
          REPO: ${{ steps.setvars.outputs.repo }}
          AWS_REGION: ${{ env.AWS_REGION }}
        run: |
          set -euo pipefail
          REGISTRY="${REPO%%/*}"
          aws ecr get-login-password --region "$AWS_REGION" \
          | docker login --username AWS --password-stdin "$REGISTRY"

      - name: Build & push image
        id: buildpush
        env:
          REPO: ${{ steps.setvars.outputs.repo }}
        run: |
          set -euo pipefail
          GIT_SHA="${GITHUB_SHA::7}"
          docker build -t "$REPO:latest" -t "$REPO:$GIT_SHA" .
          docker push "$REPO:latest"
          docker push "$REPO:$GIT_SHA"
          echo "image_tag=$GIT_SHA" >> "$GITHUB_OUTPUT"

      - name: Update ECS service to new image
        env:
          CLUSTER:   ${{ steps.setvars.outputs.cluster }}
          SERVICE:   ${{ steps.setvars.outputs.service }}
          CONTAINER: ${{ env.CONTAINER_NAME }}
          NEW_IMAGE: ${{ steps.setvars.outputs.repo }}:${{ steps.buildpush.outputs.image_tag }}
        run: |
          set -euo pipefail
          TD_ARN=$(aws ecs describe-services --cluster "$CLUSTER" --services "$SERVICE" --query "services[0].taskDefinition" --output text)
          aws ecs describe-task-definition --task-definition "$TD_ARN" --query "taskDefinition" > td.json
          jq --arg name "$CONTAINER" --arg image "$NEW_IMAGE" '
            .containerDefinitions |= (map(if .name==$name then .image=$image else . end))
            | del(.taskDefinitionArn,.revision,.status,.requiresAttributes,.compatibilities,.registeredAt,.registeredBy)
          ' td.json > new-td.json
          NEW_TD_ARN=$(aws ecs register-task-definition --cli-input-json file://new-td.json --query "taskDefinition.taskDefinitionArn" --output text)
          aws ecs update-service --cluster "$CLUSTER" --service "$SERVICE" --task-definition "$NEW_TD_ARN"
          aws ecs wait services-stable --cluster "$CLUSTER" --services "$SERVICE"

      - name: Optional health check
        run: |
          echo "Hit your ALB: http://fastapi-todo-alb-1251451819.eu-west-2.elb.amazonaws.com/health"
